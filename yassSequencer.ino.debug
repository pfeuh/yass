/*
 * file : yassSequencer.ino
 * Copyright (c) pfeuh <ze.pfeuh@gmail>
 * All rights reserved.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/****************************************/
/*  This is the DEBUG version of YASS   */
/* MIDI port is on Serial1 - MEGA board */
/****************************************/

#include "yassTicks.h"
#include "yassSequencer.h"
#include "yassRomSequences.h"
#include "yassSequence.h"
#include "yassConfig.h"
#include <MIDI.h>

#define MIDI_CLOCK 0xF8
#define CC_ALL_NOTES_OFF 120

#define YASS_EEPROM_ADDR 0

#define YASS_SYSEX_HEADER_1 'Y'
#define YASS_SYSEX_HEADER_2 'A'
#define YASS_SYSEX_HEADER_3 'S'

#define YASS_SYSEX_CMD_PLAY           1
#define YASS_SYSEX_CMD_STOP           2
#define YASS_SYSEX_CMD_CONT           3
#define YASS_SYSEX_CMD_REC            4
#define YASS_SYSEX_CMD_SEQ1           5
#define YASS_SYSEX_CMD_SEQ2           6
#define YASS_SYSEX_CMD_SEQ3           7
#define YASS_SYSEX_CMD_SEQ4           8
#define YASS_SYSEX_CMD_SEQ5           9
#define YASS_SYSEX_CMD_CONFIG_CFG     10
#define YASS_SYSEX_CMD_SEQUENCE_CFG   11
#define YASS_SYSEX_CMD_OK             12
#define YASS_SYSEX_CMD_REST           13
#define YASS_SYSEX_CMD_TIE            14
#define YASS_SYSEX_CMD_LAST_STEP      15
#define YASS_SYSEX_CMD_DATA_PLUS      16
#define YASS_SYSEX_CMD_DATA_MINUS     17
#define YASS_SYSEX_CMD_LOAD_SEQUENCE  18
#define YASS_SYSEX_CMD_LOAD_ALL       19
#define YASS_SYSEX_CMD_SAVE_SEQUENCE  20
#define YASS_SYSEX_CMD_SAVE_ALL       21

#define YASS_SYSEX_DATA_STEP_LEDS     64
#define YASS_SYSEX_DATA_KEY_LEDS      65
#define YASS_SYSEX_DATA_DIGITS        66

/* YASS GLOBAL CONFIGURATION */
YASS_CONFIG globConf = YASS_CONFIG();

#define YASS_SEQ_MAX_NOTES 16
YASS_SEQUENCE seqs[] = 
{
    YASS_SEQUENCE(YASS_SEQ_MAX_NOTES),
    YASS_SEQUENCE(YASS_SEQ_MAX_NOTES),
    YASS_SEQUENCE(YASS_SEQ_MAX_NOTES),
    YASS_SEQUENCE(YASS_SEQ_MAX_NOTES),
    YASS_SEQUENCE(YASS_SEQ_MAX_NOTES)
};

#define NB_SEQS (sizeof(seqs) / sizeof(YASS_SEQUENCE))

/* YASS SEQUENCER */
YASS_SEQUENCER player = YASS_SEQUENCER();

/* INTERNAL BPM MANAGMENT */
YASS_TICKS ticks = YASS_TICKS();
#define DEFAULT_BPM 120

/* SERIAL INTERFACE */
#define HMI Serial
#define PC_BAUDRATE 9600

/* MIDI INTERFACE */
MIDI_CREATE_INSTANCE(HardwareSerial, Serial1, MIDI);
#define MIDI_OUTPUT_CHANNEL 1

word userValue;
char command;
bool recording = false;
byte recordIndex;

#define MAX_DISPLAY_COL_NUM 40
//~ #define DEBUG_RECEIVED_MIDI
#define DEBUG_SENT_MIDI

#ifdef DEBUG_RECEIVED_MIDI
#define ADD_DEBUG_CONSOLE
#endif
#ifdef DEBUG_SENT_MIDI
    #ifndef ADD_DEBUG_CONSOLE
        #define ADD_DEBUG_CONSOLE
    #endif
#endif

#ifdef ADD_DEBUG_CONSOLE
const char PROGMEM hexLut[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
byte colNum;
void printHexByte(byte value)
{
    HMI.write(pgm_read_byte(hexLut + (value >> 4)));
    HMI.write(pgm_read_byte(hexLut + (value & 15)));
    colNum += 2;
}

void printChar(char value)
{
    HMI.write(value);
    colNum++;
}

void wrap()
{
    if(colNum >= MAX_DISPLAY_COL_NUM)
    {
        colNum = 0;
        HMI.write('\n');
    }
}

void printMidiMessage(byte a, byte b, byte c)
{
    printHexByte(a);
    printHexByte(b);
    printHexByte(c);
    printChar(' ');
    wrap();
}
#endif

void printMenu()
{
    HMI.println(F(" A[0:1] All channels (omni mode)"));
    HMI.println(F(" B[0:127] Next scale"));
    HMI.println(F("[C] Continue sequencer"));
    HMI.println(F(" D[0:1] Don't use program change"));
    HMI.println(F(" E[0:127] Split point"));
    HMI.println(F(" F[0:1] Midi sync out"));
    HMI.println(F(" I[1:16] Input channel"));
    HMI.println(F("[M]enu"));
    HMI.println(F(" O[1:16] Output channel"));
    HMI.println(F(" Q[0:1] Use eXclusive"));
    HMI.println(F("[R] Record sequence"));
    HMI.println(F("[S] Start/stop sequencer"));
    HMI.println(F(" V[0:127] Voice select"));
    HMI.println(F("[W] Groove"));
    HMI.println(F(" X[1:5]Sequence select"));
    HMI.println(F(" Y[1:..] Load ROM sequence"));
    HMI.println(F(" Z[0:15] Last step"));
    HMI.println(F("[?] View global config"));
    HMI.println(F(" ?[1:5] View sequence config"));
    HMI.println(F(" ?100 View sequencer config"));
    HMI.println(F("  [55:280] Tempo"));
    HMI.println(F("  [.-_] Short, normal, long notes"));
    HMI.println(F("  [!] All notes off"));
}

void startRecording()
{
    if(!recording)
    {
        recording = true;
        recordIndex = 0;
        HMI.println(F("Sequencer is recording!"));
    }
}

void stopRecording()
{
    if(recording)
    {
        recording = false;
        HMI.println(F("End of recording session!"));
    }
}

void addRecordedNote(byte note, byte velocity)
{
    YASS_SEQUENCE* seq = player.getCurrentSequence();
    seq->setNote(recordIndex, note);
    seq->setData(recordIndex, note);
    seq->setLastStep(recordIndex);
    recordIndex++;
    #ifdef DEBUG_SENT_MIDI
    printHexByte(recordIndex);
    printChar(' ');
    printHexByte(note);
    printChar(' ');
    printHexByte(velocity);
    printChar('\n');
    #endif
    if(recordIndex >= YASS_SEQ_MAX_NOTES)
        stopRecording();
}

/*********************/
/* midi in callbacks */
/*********************/

void receiveExclusive(byte * array, unsigned size)
{
    #ifdef DEBUG_RECEIVED_MIDI
    byte cursor = 0;
    while(cursor < size)
    {
        printHexByte(*(array+(cursor++)));
        printChar(' ');
        wrap();
    }
    #else
    array++;
    size++;
    #endif
}

void receiveNoteOn(byte channel, byte note, byte velocity)
{
    if((globConf.getOmni() || (globConf.getChannelIn() == channel)))
    {
        if(player.isRunning())
        {
            if(note < globConf.getSplitPoint())
                player.setNextScale(note % 12);
            else
                MIDI.sendNoteOn(note, velocity, globConf.getChannelOut());
        }
        else
        {
            if(recording)
                addRecordedNote(note, velocity);
            MIDI.sendNoteOn(note, velocity, globConf.getChannelOut());
        }
    }
    #ifdef DEBUG_RECEIVED_MIDI
    printMidiMessage(channel - 1 + midi::NoteOn, note, velocity);
    #else
    channel++;
    velocity++;
    note++;
    #endif
}

void receiveNoteOff(byte channel, byte note, byte velocity)
{
    if((globConf.getOmni() || (globConf.getChannelIn() == channel)))
    {
        if(player.isRunning())
        {
            if(note >= globConf.getSplitPoint())
                MIDI.sendNoteOff(note, velocity, globConf.getChannelOut());
        }
        else
            MIDI.sendNoteOff(note, velocity, globConf.getChannelOut());
    }
    #ifdef DEBUG_RECEIVED_MIDI
    printMidiMessage(channel - 1 + midi::NoteOff, note, velocity);
    #else
    channel++;
    velocity++;
    note++;
    #endif
}
void receiveControlChange(byte channel, byte number, byte value)
{
    #ifdef DEBUG_RECEIVED_MIDI
    printMidiMessage(channel - 1 + midi::ControlChange, number, value);
    #else
    channel++;
    number++;
    value++;
    #endif
}

/**********************/
/* midi out callbacks */
/**********************/

void controlChange(byte cc_num, byte cc_value)
{
    MIDI.sendControlChange(cc_num, cc_value, globConf.getChannelOut());
}

void allNotesOff()
{
    controlChange(CC_ALL_NOTES_OFF, 0);
}

void programChange(byte prog_num)
{
    MIDI.sendProgramChange(prog_num, globConf.getChannelOut());
}

/***************/
/* user's jobs */
/***************/

void changeOutputChannel(byte new_channel)
{
    if((new_channel >= YASS_CONFIG_MIN_CHANNEL) && (new_channel <= YASS_CONFIG_MAX_CHANNEL))
    {
        
        globConf.setChannelOut(new_channel);
        if(HMI)
        {
            HMI.print(F("Output channel:"));
            HMI.println(new_channel);
        }
    }
}

void noteOn(byte note, byte velocity)
{
    MIDI.sendNoteOn(note, velocity, globConf.getChannelOut());
    
    #ifdef DEBUG_SENT_MIDI
    printHexByte(note);
    printChar(' ');
    wrap();
    
    //~ printMidiMessage(globConf.getChannelOut() - 1 + midi::NoteOn, note, velocity);
    #endif
}

void noteOff(byte note)
{
    MIDI.sendNoteOff(note, 0, globConf.getChannelOut());
}

void clockCallback()
{
    if(!globConf.getClockIn())
        if(player.isRunning())
        {
            if(globConf.getClockOut())
                MIDI.sendRealTime(midi::Clock);
        }
}

void startCallback()
{
    if(!globConf.getClockIn())
    {
    }
}

void stopCallback()
{
    if(!globConf.getClockIn())
    {
    }
}
-
void continueCallback()
{
    if(!globConf.getClockIn())
    {
    }
}

void tickTask(byte tick_num)
{
    if(!globConf.getClockIn())
    {
        if(!tick_num)
            digitalWrite(LED_BUILTIN, 0);
        else if(tick_num == (YASS_TICKS_RESOLUTION / 2))
            digitalWrite(LED_BUILTIN, 1);  
        if(globConf.getClockOut())
            MIDI.sendRealTime(midi::Clock);
        player.tickTask();    
    }
}

void setGroove()
{
    if(userValue <= YASS_GROOVE_MAX)
    {
       //~ player.setGroove(player.getCurrentSequence(), userValue);
        player.getCurrentSequence()->setGroove(userValue);
    }
}
void executeCommand()
{
    switch(command)
    {
        case 'R':
            if(!player.isRunning())
            {
                if(recording)
                    stopRecording();
                else
                    startRecording();
            }
            break;
        case 'S':
            if(!recording)
            {
                if(!player.isRunning())
                {
                    player.startSequencer();
                    if(globConf.getClockOut())
                        MIDI.sendRealTime(midi::Start);
                    HMI.println(F("Sequencer is started!"));
                }
                else
                {
                    player.stopSequencer();
                    if(globConf.getClockOut())
                        MIDI.sendRealTime(midi::Stop);
                    HMI.println(F("Sequencer is stopped!"));
                }
            }
            break;
        case 'C':
            if(!recording)
            {
                if(!player.isRunning())
                {
                    player.continueSequencer();
                    if(globConf.getClockOut())
                        MIDI.sendRealTime(midi::Continue);
                    HMI.println(F("Sequencer is continuing!"));
                }
                else
                {
                    player.stopSequencer();
                    if(globConf.getClockOut())
                        MIDI.sendRealTime(midi::Stop);
                    HMI.println(F("Sequencer is stopped!"));
                }
            }
            break;
        case 'F':
            globConf.setClockOut(userValue);
            HMI.println(F("Clock out "));
            HMI.println(globConf.getClockOut());
            break;
        case 'B':
            player.setNextScale(userValue);
            HMI.println(F("Next Scale "));
            HMI.println(player.getNextScale());
            break;
        case 'X':
            player.setNextSequence(userValue - 1);
            HMI.print(F("next sequence is "));
            HMI.println(player.getNextSequenceIndex() + 1);
            break;
        case '.':
            if(recording)
                addRecordedNote(YASS_REST, YASS_DEFAULT_VELOCITY);
            else
                player.getCurrentSequence()->setGateMode(YASS_SEQUENCE_GATE_SHORT);
            break;
        case '-':
            player.getCurrentSequence()->setGateMode(YASS_SEQUENCE_GATE_NORMAL);
            break;
        case '_':
            if(recording)
                addRecordedNote(YASS_TIE, YASS_DEFAULT_VELOCITY);
            else
                player.getCurrentSequence()->setGateMode(YASS_SEQUENCE_GATE_LONG);
            break;
        case 'O':
            changeOutputChannel(userValue);
            break;
        case 'I':
            if((userValue >= YASS_CONFIG_MIN_CHANNEL) && (userValue <= YASS_CONFIG_MAX_CHANNEL))
            {
                globConf.setChannelIn(userValue);
                HMI.print(F("Input channel "));
                HMI.println(userValue);
            }
            break;
        case '?':
            if(userValue == 100)
                player.print();
            else
            {
                if(userValue <= NB_SEQS)
                {
                    if(!userValue)
                    {
                        globConf.print();
                        HMI.print(F("tempo "));
                        HMI.println(ticks.getTempo());
                        HMI.print(F("recording "));
                        HMI.println(recording);
                    }
                    else
                    {
                        YASS_SEQUENCE* seq = player.getSequence(userValue - 1);
                        HMI.print(F("---*** sequence number "));
                        HMI.print(userValue);
                        HMI.println(F(" ***---"));
                        seq->print();
                    }
                }
            }
            break;
        case '!':
            allNotesOff();
            HMI.println(F("All notes muted"));
            break;
        case 'M':
            printMenu();
            break;
        case 'D':
            globConf.setDontUseProgNum(userValue);
            HMI.print(F("Don't use program change :"));
            HMI.println(globConf.getDontUseProgNum());
            break;
        case 'A':
            globConf.setOmni(userValue);
            HMI.print(F("All channels (omni mode) :"));
            HMI.println(globConf.getOmni());
            break;
        case 'V':
            globConf.setProgNum(userValue);
            if(!globConf.getDontUseProgNum())
                programChange(globConf.getProgNum());
            HMI.print(F("Voice (program):"));
            HMI.println(globConf.getProgNum());
            break;
        case 'W':
            allNotesOff();
            setGroove();
            break;
        case 'Q':
            globConf.setUseSysEx(userValue);
            HMI.print(F("Use Exclusive:"));
            HMI.println(globConf.getUseSysEx());
            break;
        case 'Y':
            YASS_ROM_SEQUENCES_load(userValue - 1, player.getCurrentSequence());
            HMI.print(F("ROM sequence "));
            HMI.print(userValue);
            HMI.println(F(" loaded"));
            break;
        case 'Z':
            if(userValue < YASS_SEQ_MAX_NOTES)
                player.getCurrentSequence()->setLastStep(userValue);
            break;
        case 'E':
            globConf.setSplitPoint(userValue);
            HMI.print(F("Split point is "));
            HMI.println(globConf.getSplitPoint());
            break;
        default:
            break;
    }
    command = 0;
    userValue = 0;
}

void userSequencer()
{
    if(HMI.available())
    {
        char car = HMI.read();
        switch(car)
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                userValue = userValue * 10 + car - '0';
                break;
            case '\n':
                if(command)
                    executeCommand();
                else
                {
                    ticks.setTempo(userValue);
                    HMI.print(F("Tempo is "));
                    HMI.println(ticks.getTempo());
                    userValue = 0;
                    command = 0;
                }
                break;
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'i':
            case 'm':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 'x':
            case 'v':
            case 'w':
            case 'y':
            case 'z':
                command = car - 'a' + 'A';
                break;
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'I':
            case 'M':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'X':
            case 'V':
            case 'W':
            case 'Y':
            case 'Z':
            case '?':
            case '!':
            case '.':
            case '-':
            case '_':
                command = car;
                break;
            default:
                break;
        }
    }
}

void setup()
{
    
    HMI.begin(PC_BAUDRATE);
    HMI.println(F("yassSequencer v. " YASS_SEQUENCER_VERSION));
    HMI.println(F(__DATE__ " " __TIME__));
    
    //~ YASS_ROM_SEQUENCES_info();
    
    printMenu();
    HMI.flush();

    MIDI.begin(MIDI_CHANNEL_OMNI);
    MIDI.turnThruOff();
    MIDI.setHandleSystemExclusive(receiveExclusive);
    MIDI.setHandleNoteOn(receiveNoteOn);
    MIDI.setHandleNoteOff(receiveNoteOff);
    MIDI.setHandleControlChange(receiveControlChange);
    MIDI.setHandleClock(clockCallback);
    MIDI.setHandleStart(startCallback);
    MIDI.setHandleStop(stopCallback);
    MIDI.setHandleContinue(continueCallback);
    
    ticks.begin();
    ticks.setCallback(&tickTask);
    ticks.setTempo(DEFAULT_BPM);
    ticks.start();
    
    player.begin(NB_SEQS, seqs, YASS_SEQ_MAX_NOTES);
    player.setStartCallback(&noteOn);
    player.setStopCallback(&noteOff);
    player.setClockCallback(clockCallback);

    globConf.setSplitPoint(53);

    YASS_ROM_SEQUENCES_load(YASS_ROM_SEQUENCE_BILLIE_JEAN, &seqs[0]);
    YASS_ROM_SEQUENCES_load(YASS_ROM_SEQUENCE_MIDNIGHT_EXPRESS, &seqs[1]);
    YASS_ROM_SEQUENCES_load(YASS_ROM_SEQUENCE_BLADE_RUNNER, &seqs[2]);
    YASS_ROM_SEQUENCES_load(YASS_ROM_SEQUENCE_MAJOR_ARPEGGIO, &seqs[3]);
    YASS_ROM_SEQUENCES_load(YASS_ROM_SEQUENCE_TUBULAR_BELLS, &seqs[4]);

    pinMode(LED_BUILTIN, OUTPUT);
}

void loop()
{
    MIDI.read();
    userSequencer();
    ticks.sequencer(); // if a tick occurs, player.tickTask runs one time
}

